С точки зрения ВЗАИМОДЕЙСТВИЯ С ВНЕШНИМ различают два основных вида подзапросов: коррелированные и некоррелированные.

НЕКОРЕЛИРОВАНИЕ
  Выполняются независимо от основного запроса.
  Обычно некоррелированный подзапрос ВИПОЛНЯЮТСЯ ОДИН РАЗ ПЕРЕД ОСНОВНИМ, а потом ДЛЯ ОСНОВНОГО ИСПОЛЬЗУЄТЬСЯ РЕЗУЛЬТАТ.

  SELECT Name
  FROM Salary
  WHERE Amount > (SELECT Amount FROM Salary WHERE Name = 'Вася')


КОРРЕЛИРОВАНИЕ
  Получают данные из внешнего запроса и зачастую могут служить альтернативой объединению таблиц.

  SELECT a.AccountID,
         ( SELECT c.LastName
           FROM Clients c
           WHERE c.ClientID = a.ClientID )
  FROM Accounts a
  WHERE a.Currency = 'UAH'

  В данном примере сначала начнет выполняться основной запрос, будет сформирована выборка данных из таблицы Accounts,
  после чего для каждой записи из этой выборки будет выполнен подзапрос, возвращающий фамилию клиента из таблицы Clients.


EXISTS
  SELECT *
  FROM Clients c
  WHERE NOT EXISTS( SELECT 1 FROM Accounts a WHERE a.ClientID = c.ClientID )

  Для EXISTS важен только факт наличия или отсутствия записей в возвращаемом подзапросом resultset.


GROUP BY
  Применение предложения GROUP BY позволяет разделить таблицу на наборы данных.
  Если агрегатная функция используется в выборке без GROUP BY, то она применяется ко всем записям выборки,
  иначе для каждой группы в отдельности


  Используя предложение WHERE, вы можете ограничить количество данных, которые будут подвергнуты групповой обработке
  GROUP BY


HAVING
  Для отбора групп по условию существует оператор HAVING.
  Предложение HAVING можно использовать только в инструкции SELECT.
  Предложение HAVING обычно используется в предложении GROUP BY.

  Когда GROUP BY не используется, предложение HAVING работает так же, как и предложение WHERE.
  С точки зрения условного выражения, HAVING и WHERE идентичны, отличие состоит лишь в том,
  что в условии предложения WHERE не могут находится агрегирующие функции.


  Последовательность вычисления результатов запроса:
    1) Исключаются строки не удовлетворяющие условиям предложения WHERE
    2) Оставшиеся строки объединяются в наборы согласно выражению GROUP BY
    3) Для каждого набора вычисляются агрегаты
    4) Из наборов, удовлетворяющих условиям HAVING, формируется результат


  В этом случае, действие HAVING аналогично действию WHERE, т.к. условия HAVING накладываются на все строки таблицы,
  которая трактуется как единая группа. Кроме того, в условии возможно использование агрегирующих функций:

  SELECT dbid, crdate, size
    FROM sysusages
    WHERE crdate < ‘2005-01-01’
    HAVING size > avg(size)


UNIQUE.
  Данное ограничение во многом схоже с ограничением PRIMARY KEY.
  Его использование также обеспечивает уникальность значения поля или группы полей в рамках таблицы.

  Отличия заключаются в том, что первичный ключ у таблицы может быть только один,
  а уникальных полей (или их комбинаций) - несколько. Кроме того, поля, на которые наложено ограничение UNIQUE,
  в отличие от полей первичного ключа, могут допускать значения NULL (если на них не наложено дополнительное
  ограничение NOT NULL). Индекс, создаваемый для ограничения UNIQUE, по умолчанию NONCLUSTERED.
  Ограничение UNIQUE может быть использовано, например, для описания альтернативных ключей таблицы.

  Практически любая таблица должна содержать поле или несколько полей, комбинация значений которых позволяет
  однозначно идентифицировать запись. Такое поле или комбинация полей называется первичным ключом.


FOREIGN KEY ... REFERENCES
  Данное ограничение позволяет описать взаимосвязи между таблицами с целью поддержания ссылочной целостности.
  Поле (поля), на которые накладывается данное ограничение, обозначаются как внешний ключ, для которого устанавливается
  связь с первичным (PRIMARY KEY) или уникальным (UNIQUE) ключом другой таблицы.

  Ключевое слово FOREIGN KEY определяет поля в текущей таблице, чьи значения должны совпадать со значениями полей в
  родительской таблице или быть NULL. REFERENCES определяет родительскую таблицу (так же возможны ссылки "сам на себя")
  и те столбцы в ней, с которыми устанавливается связь. Если столбцы родительской таблицы явно не указывать, считается,
  что ссылка идет на первичный ключ.


Если редактируемая запись содержит поле timestamp, можно модифицировать алгоритм следующим образом:
  Получаем информацию из БД, запоминаем значение timestamp
  Заполняем полученной информацией форму редактирования
  После редактирвоания проверяем, совпадает ли текущее значение поля timestamp с запомненным на шаге 1
  Если совпадает, сохраняем информацию в БД, иначе сообщаем пользователю о том, что кто-то успел раньше него


ТРАНЗАКЦИИ (концепция)
    Атомарность
      - транзакция должна функционировать как единая неделимая единица работы таким образом что все или ничего.
    Непротиворечивость
      - база данных должна всегда переходить из одного непротиворечивого состояния в последующее.
        Если по бизнес логике деньги списани из одного счета то они должни бить зачислени на другой. Это бизнес-правило и
        оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании
        кода транзакций
    Изолированность
      - во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
    Долговечность
      - изменения должны быть записаны так, чтобы данные не могли быть потеряны в случае сбоя сис­темы

УРОВЕНЬ ИЗОЛЯЦИИ - определяет степень закрытости данных на время транзакции



При параллельном выполнении транзакций возможны следующие проблемы
  - «грязное» чтение (уровень READ UNCOMMITTED)

    Transaction 1                Transaction 2
      select                        ...
      update                        ...
       ...                         select      <- this one has wrong data
      roll back


  - неповторяющееся чтение (уровень READ COMMITTED)
    при повторном чтении в рамках одной транзакции, ранее прочитанные данные оказываются изменёнными или удалёнными.
    Это означает, что вы можете выполнить одну и ту же команду дважды и получить различный результат.

      Transaction 1                Transaction 2
         select                       select
         update                        ...
         commit                        ...
         ....                         select


  - фантомное чтение (уровень REPEATABLE READ)
    Попросту говоря, фантомное чтение может происходить в случае, если в одной транзакции выбирается некоторый
    диапазон строк, затем другая транзакция вставляет новую строку в этот диапазон, после чего в первой транзакции
    выбирается тот же диапазон снова. В результате первая транзакция увидит новую «фантомную» строку.

    Transaction 1                Transaction 2
         ...                      select sum(*)
        insert                        ...
        commit                        ...
         ...                      select sum(*)








